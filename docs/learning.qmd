---
title: "LearnR3"
author: "Ingrid M. Wagnon"
format:
  html:
    number-sections: true
    markdown:
      hardline-breaks: true
---

Note about the YAML : Very sensitive to spacing and tabulation.

Keep your stable, robust functions in a separate file for easier re-use across your files, for instance, in the R/functions.R file. You can re-use the functions by using source(here("R/functions.R")) in your Quarto documents.

To make sure your code runs smoothly use the function usethis::use_package("library called") in the console which should add the necessary packages to the DESCRIPTION file.
For tidyverse use : usethis::use_package("tidyverse", type = "Depends").

```{r setup}
library(tidyverse)
library(here)
library(snakecase)
library(fs)
library(purrr)
library(stringr)
source(here("R/functions.R"))

cgm_data <- here("data-raw/dime/cgm") |>
  import_csv_files() |>
  get_participant_id() |>
  prepare_dates(device_timestamp)

sleep_data <- here("data-raw/dime/sleep") |>
  import_csv_files() |>
  get_participant_id() |>
  rename(datetime = date) |>
  prepare_dates(datetime)
```


# Importing Raw Data

## Import CGM

Just about GitHub : If you want it private you can add a private argument.

When you load data from a CSV file into R with read_csv(), the function will try to guess what the data types are for each column. Usually it guesses accurately.
The argument show_col_types = FALSE tells R to just guess and to not give a warning message.
Otherwise we could explicitly tell read_csv() what the column names and data types are using the argument col_types. This is a very tedious, but often very powerful and useful step depending on the issues your data may have.

The column names are not in a format that we can easily use. For example, the first column is called "Device Timestamp" and the space in the name will make it harder to work with. So, we will need to fix the column names up to follow a common style and that is easier to code with. That style is snake_case that uses _ for spaces and is all lower case.
The function from snakecase that we want to use in the name_repair argument is the to_snake_case() function. To convert the variable names to snake case, we would add name_repair = to_snake_case to the code

The n_max argument to only load in the first 100 rows

If necessary (not shown in this example) you can use col_select = arguments in read_csv() to import only the data you need.

```{r importing csv}
cgm_101 <- here("data-raw/dime/cgm/101.csv") |>
  read_csv(
    show_col_types = FALSE,
    name_repair = to_snake_case,
    n_max = 100
  )
```


## Exercise: Import 101's sleep data

```{r importing csv exercise}
sleep_101 <- here("data-raw/dime/sleep/101.csv") |>
  read_csv(
    show_col_types = FALSE,
    name_repair = to_snake_case,
    n_max = 101
  )
sleep_101
```


# Creating Functions

Basic structure of a function:  

name <- function(argument1, argument2) {  
    # body of function  
    output <- ... code ....  
    return(output)  
}  

## Making a function to add numbers

```{r example of adding numbers}
#' Add two numbers together.
#'
#' @param num1 A number here.
#' @param num2 A number here.
#'
#' @return Returns the sum of the two numbers.
#'

add_numbers <- function(num1, num2) {
  added <- num1 + num2
  return(added)
}

add_numbers(1, 2)
```

## Import 101's cgm data with a function

From how we import our data we create a function.

It's good practice to not hard code the use of here() within a function. Instead, it’s good design to give functions a full file path that it can use internally. Then when we use the function, we would use here() with the correct path in the function argument. 

Then we simplify things internally by renaming cgm_101 to simply cgm, since we would like to be able to import other participant CGM data later.

```{r create cgm function}
#' Import one participants CGM data from the DIME dataset.
#'
#' @param file_path Path to the CGM dataset.
#'
#' @returns Outputs a data frame/tibble.
#'
import_cgm <- function(file_path) {
  cgm <- file_path |>
    read_csv(
      show_col_types = FALSE,
      name_repair = to_snake_case,
      n_max = 100
    )
  return(cgm)
}
```

```{r test 1 cgm}
here("data-raw/dime/cgm/101.csv") |>
  import_cgm()
```

```{r test 2 cgm}
here("data-raw/dime/cgm/102.csv") |>
  import_cgm()
```

# Exercise : Create sleep function

name <- function(argument1, argument2) {  
    # body of function  
    output <- ... code ....  
    return(output)  
}  

```{r create sleep function}
#' Import one participants SLEEP data from the DIME dataset.
#'
#' @param file_path Path to the CGM dataset.
#'
#' @returns Outputs a data frame/tibble.
#'
import_sleep <- function(file_path) {
  sleep <- file_path |>
    read_csv(
      show_col_types = FALSE,
      name_repair = to_snake_case,
      n_max = 101
    )
  return(sleep)
}
```

```{r test 1 sleep}
here("data-raw/dime/sleep/101.csv") |>
  import_sleep()
```

```{r test 2 sleep}
here("data-raw/dime/sleep/102.csv") |>
  import_sleep()
```

# Import DIME data function : Make function more general

Specifically call the package from which the function you are using comes from 

To make sure your code runs smoothly use the function usethis::use_package("library called") in the console which should add the necessary packages to the DESCRIPTION file.
For tidyverse use : usethis::use_package("tidyverse", type = "Depends")

The following is supposed to be a code but we technically need to CUT and PASTE into the functions.R file - but I kept it here to see the final product as text.

 {r import_dime function}  
 #' Import data from the DIME study dataset.  
 #'  
 #' @param file_path Path to the CSV file.  
 #' @param n Optional parameter that limits the number of rows. Default is 100.  
 #'  
 #' @returns A data frame.  
 #'  
 import_dime <- function(file_path, n = 100) {  
   data <- file_path |>  
     readr::read_csv(  
       show_col_types = FALSE,  
       name_repair = snakecase::to_snake_case,  
       n_max = n  
     )  
   return(data)  
 }

```{r use funciton import dime on cgm and sleep}
here("data-raw/dime/cgm/101.csv") |>
  import_dime()
here("data-raw/dime/sleep/101.csv") |>
  import_dime()
```


```{r homemade data snake function}
#' Import data from dime
#'
#' @param typedata cmg or sleep.
#' @param id Patient ID number.
#' @param n Optional but number of row, default is 100.
#'
#' @returns Output data tibble.
#'
import_data_snake <- function(typedata, id, n = 100) {
  datasnake <- here::here(paste0("data-raw/dime/", as.character(typedata), "/", as.character(id), ".csv")) |>
    readr::read_csv(
      show_col_types = FALSE,
      name_repair = snakecase::to_snake_case,
      n_max = n
    )
  return(datasnake)
}
```

```{r test snake}
import_data_snake("sleep", "101", 93)
```


# Using map

The dir_ls() function takes the path that we want to search, in this case data-raw/dime/cgm and has an argument called glob to tell it what type of files to search for. In our case, we want to search for all CSV files in the data-raw/dime/cgm/ folder. So we will pipe the output of the path to the CGM folder with here() into dir_ls():

```{r dirl_ls}
cgm_files <- here("data-raw/dime/cgm/") |>
  dir_ls(glob = "*.csv")

cgm_files
```

```{r map}
cgm_data_mapuse <- cgm_files |>
  map(import_dime)

cgm_data_mapuse[1:2] # this is to import only 2 dataset instead of 101 of them
```

There are two functions that take a list of data frames and convert them into a single data frame. They are called list_rbind() to bind (“stack”) the data frames by rows or list_cbind() to bind (“stack”) the data frames by columns. In our case, we want to bind (stack) by rows, so we will use list_rbind() by piping the output of the map() code we wrote into list_rbind().

```{r map and list_bind}
cgm_data_mapuse <- cgm_files |>
  map(import_dime) |>
  list_rbind()

cgm_data_mapuse
```

list_rbind() has an argument called names_to. This argument lets us create a new column that is based on the name of the list item, which in our case is the file path. This file path also has the participant ID information in it, but it also has the full file path in it too, which isn’t exactly what we want. So we’ll have to fix it later. But first, let’s start with adding this information to the data frame as a new column called file_path_id.

```{r add names_to}
cgm_data_mapuse <- cgm_files |>
  map(import_dime) |>
  list_rbind(names_to = "file_path_id")

cgm_data_mapuse
```


## Convert map to function and use on sleep

 {r code function}  
 #' Import the csv files  
 #'  
 #' @param folder_path give the here("folder_path") where to look  
 #'  
 #' @returns tibble or data  
 #'  
 import_csv_files <- function(folder_path) {  
   files <- folder_path |>  
     fs::dir_ls(glob = "*.csv")  
   data <- files |>  
     purrr::map(import_dime) |>  
     purrr::list_rbind(names_to = "file_path_id")  
   return(data)  
 }  

```{r try import csv files function}
here("data-raw/dime/cgm/") |>
  import_csv_files()
here("data-raw/dime/sleep/") |>
  import_csv_files()
```


# Using Regex for ID

  {r extract ID}  
  cgm_data |>  
 mutate(  
    id = str_extract(  
      file_path_id,  
      "[:digit:]+\\.csv$"  
    ) |>  
      str_remove("\\.csv$") |>  
      as.integer(),  
    .before = file_path_id  
  ) |>  
  select(-file_path_id)  


## Exercise : Create get ID function
{ r create get ID function}  
 
 #' Get participant ID as first column  
 #'  
 #' @param data   
 #'  
 #' @returns table  
 #'  
 get_participant_id <- function(data) {  
 data_with_id <- data |>  
   dplyr::mutate(  
     id = stringr::str_extract(  
       file_path_id,  
       "[:digit:]+\\.csv$"  
     ) |>  
       stringr::str_remove("\\.csv$") |>  
       as.integer(),  
     .before = file_path_id  
   ) |>  
   select(-file_path_id)  
   return(data_with_id)  
 }  

```{r verify all is working}
cgm_data
sleep_data
```


# Working with dates

{r first how to work with dates}  
cgm_data |>  
  mutate(  
    date = as_date(device_timestamp),  
    hour = hour(device_timestamp),  
    .before = device_timestamp  
  )  


In R, NSE is what allows you to use formulas (e.g. y ~ x + x2) in statistical models or allows you to type out select(Gender, BMI) or library(purrr). In “standard evaluation”, these would instead be select("Gender", "BMI") or library("purrr"). So NSE gives flexibility and ease of use for the user (we don’t have to type quotes every time). The simplest way to use NSE in your own functions when using tidyverse packages is to wrap the variable with { } (called “curly-curly”). By wrapping column with { }, we are telling R that we are giving it an unquoted variable and to give that variable to the as_date() function as the name of the column.

 {r function for preparing dates}  
 #' Prepare the date columns in DIME CGM and sleep data for joining.   
 #'  
 #' @param data The data that has the datetime column.  
 #' @param column The datetime column to convert to date and hour.  
 #'  
 #' @returns A tibble/data.frame  
 #'  
 prepare_dates <- function(data, column) {  
   prepared_dates <- data |>  
     dplyr::mutate(  
       date = lubridate::as_date({{column}}),  
       hour = lubridate::hour({{column}}),  
       .before = {{column}}  
     )  
   return(prepared_dates)  
 }  

Insert the prepared_dates in the set up and replace the name of the column "date" in sleep data otherwise there is a conflict with 2 columns with the same name.Use rename(new name = old name).

```{r}
cgm_data
sleep_data
```
